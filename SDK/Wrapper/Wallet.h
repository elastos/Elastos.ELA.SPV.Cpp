// Copyright (c) 2012-2018 The Elastos Open Source Project
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#ifndef __ELASTOS_SDK_SPVCLIENT_WALLET_H__
#define __ELASTOS_SDK_SPVCLIENT_WALLET_H__

#include <map>
#include <string>
#include <boost/weak_ptr.hpp>
#include <boost/function.hpp>
#include <boost/thread/mutex.hpp>

#include "BRInt.h"

#include "Lockable.h"
#include "Wrapper.h"
#include "SDK/Transaction/Transaction.h"
#include "SDK/Transaction/ElementSet.h"
#include "SDK/Transaction/UTXOList.h"
#include "Address.h"
#include "MasterPubKey.h"
#include "SDK/Transaction/TransactionOutput.h"
#include "WrapperList.h"
#include "Account/ISubAccount.h"
#include "Address.h"

namespace Elastos {
	namespace ElaWallet {

		class Wallet : public Lockable {

		public:
			class Listener {
			public:
				// func balanceChanged(_ balance: UInt64)
				virtual void balanceChanged(uint64_t balance) = 0;

				// func txAdded(_ tx: BRTxRef)
				virtual void onTxAdded(const TransactionPtr &transaction) = 0;

				// func txUpdated(_ txHashes: [UInt256], blockHeight: UInt32, timestamp: UInt32)
				virtual void onTxUpdated(const std::string &hash, uint32_t blockHeight, uint32_t timeStamp) = 0;

				// func txDeleted(_ txHash: UInt256, notifyUser: Bool, recommendRescan: Bool)
				virtual void onTxDeleted(const std::string &hash, bool notifyUser, bool recommendRescan) = 0;
			};

		public:

			Wallet(const std::vector<TransactionPtr> &transactions,
				   const SubAccountPtr &subAccount,
				   const boost::shared_ptr<Listener> &listener);

			virtual ~Wallet();

			void initListeningAddresses(const std::vector<std::string> &addrs);

			uint32_t getBlockHeight() const;

			nlohmann::json GetBalanceInfo();

			void RegisterRemark(const TransactionPtr &transaction);

			std::string GetRemark(const std::string &txHash);

			uint64_t GetBalanceWithAddress(const std::string &address);

			// returns the first unused external address
			std::string getReceiveAddress() const;

			// writes all addresses previously generated with BRWalletUnusedAddrs() to addrs
			// returns the number addresses written, or total number available if addrs is NULL
			std::vector<std::string> getAllAddresses();

			// true if the address was previously generated by BRWalletUnusedAddrs() (even if it's now used)
			// int BRWalletContainsAddress(BRWallet *wallet, const char *addr);
			bool containsAddress(const std::string &address);

			// true if the address was previously used as an input or output in any wallet transaction
			// int BRWalletAddressIsUsed(BRWallet *wallet, const char *addr);
			bool addressIsUsed(const std::string &address);

//			std::vector<TransactionPtr> getTransactions() const;

//			std::vector<TransactionPtr> getTransactionsConfirmedBefore(uint32_t blockHeight) const;

			uint64_t getBalance() const;

			uint64_t getTotalSent();

			uint64_t getTotalReceived();

			uint64_t getFeePerKb();

			void setFeePerKb(uint64_t fee);

			uint64_t getMaxFeePerKb();

			uint64_t getDefaultFeePerKb();

			TransactionPtr
			createTransaction(const std::string &fromAddress, uint64_t fee, uint64_t amount,
							  const std::string &toAddress, const std::string &remark,
							  const std::string &memo);

			bool containsTransaction(const TransactionPtr &transaction);

//			bool inputFromWallet(const BRTxInput *in);

			bool registerTransaction(const TransactionPtr &transaction);

			void removeTransaction(const UInt256 &transactionHash);
			//fixme [refactor]

			void updateTransactions(const std::vector<UInt256> &transactionsHashes, uint32_t blockHeight,
									uint32_t timestamp);

			/**
			 * Returns the BRCoreTransaction with the provided `transactionHash` if it exists; otherwise
			 * NULL is returned.
			 *
			 * If BRCoreTransaction.JNI_COPIES_TRANSACTIONS is true, then the returned transaction is
			 * a copy of the Core BRTransaction - TBD caution when passed back into Core
			 *
			 * @param transactionHash
			 * @return
			 */
			TransactionPtr transactionForHash(const UInt256 &transactionHash);

			/**
			 * Check if a transaction is valid - THIS METHOD WILL FATAL if the transaction is not signed.
			 * You must call transaction.isSigned to avoid the FATAL.
		 	 *
			 * @param transaction
			 * @return
			 */
			bool transactionIsValid(const TransactionPtr &transaction);

			bool transactionIsPending(const TransactionPtr &transaction);

			bool transactionIsVerified(const TransactionPtr &transaction);

			/**
			 * Return the net amount received by this wallet.  If the amount is positive, then the balance
			 * of this wallet increased; if the amount is negative, then the balance decreased.
			 *
			 * @param tx
			 * @return
			 */
			uint64_t getTransactionAmount(const TransactionPtr &tx);

			uint64_t getTransactionFee(const TransactionPtr &tx);

			uint64_t getTransactionAmountSent(const TransactionPtr &tx);

			uint64_t getTransactionAmountReceived(const TransactionPtr &tx);

			uint64_t getBalanceAfterTransaction(const TransactionPtr &transaction);

			uint64_t getFeeForTransactionSize(size_t size);

			uint64_t getMinOutputAmount();

			uint64_t getMaxOutputAmount();

			void signTransaction(const TransactionPtr &transaction, const std::string &payPassword);

			void UpdateBalance();

		protected:
			Wallet();

			bool AddressFilter(const std::string &fromAddress, const std::string &filterAddress);

			TransactionPtr CreateTxForOutputs(const std::vector<TransactionOutput> &outputs,
											  const std::string &fromAddress,
											  const boost::function<bool (const std::string &, const std::string &)> &filter);

			uint64_t WalletMaxOutputAmount();

			uint64_t WalletFeeForTx(const TransactionPtr &tx);

			bool WalletContainsTx(const TransactionPtr &tx);

			void balanceChanged(uint64_t balance);

			void txAdded(const TransactionPtr &tx);

			void txUpdated(const std::vector<UInt256> &txHashes, uint32_t blockHeight, uint32_t timestamp);

			void txDeleted(const UInt256 &txHash, int notifyUser, int recommendRescan);

			uint64_t BalanceAfterTx(const TransactionPtr &tx);

			void sortTransations();

			std::vector<UTXO> getUTXOSafe();

			uint64_t AmountSentByTx(const TransactionPtr &tx);

		protected:
			uint64_t _balance, _totalSent, _totalReceived, _feePerKb;
			uint32_t _blockHeight;
			UTXOList _utxos;
			std::vector<TransactionPtr> _transactions;
			std::vector<uint64_t> _balanceHist;
			TransactionSet _allTx, _invalidTx, _pendingTx;
			UTXOList _spentOutputs;

			typedef std::map<std::string, std::string> TransactionRemarkMap;
			TransactionRemarkMap _txRemarkMap;
			std::vector<std::string> _listeningAddrs;

			SubAccountPtr _subAccount;
			boost::weak_ptr<Listener> _listener;
		};

		typedef boost::shared_ptr<Wallet> WalletPtr;

	}
}

#endif //__ELASTOS_SDK_SPVCLIENT_WALLET_H__
