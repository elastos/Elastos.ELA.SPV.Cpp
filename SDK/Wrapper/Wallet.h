// Copyright (c) 2012-2018 The Elastos Open Source Project
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#ifndef __ELASTOS_SDK_SPVCLIENT_WALLET_H__
#define __ELASTOS_SDK_SPVCLIENT_WALLET_H__

#include <map>
#include <string>
#include <boost/weak_ptr.hpp>
#include <boost/function.hpp>

#include "BRInt.h"

#include "Wrapper.h"
#include "SDK/Transaction/Transaction.h"
#include "SDK/Transaction/ElementSet.h"
#include "SDK/Transaction/UTXOList.h"
#include "Address.h"
#include "SharedWrapperList.h"
#include "MasterPubKey.h"
#include "SDK/Transaction/TransactionOutput.h"
#include "WrapperList.h"
#include "Account/ISubAccount.h"
#include "Address.h"

namespace Elastos {
	namespace ElaWallet {

		class Wallet {

		public:
			class Listener {
			public:
				// func balanceChanged(_ balance: UInt64)
				virtual void balanceChanged(uint64_t balance) = 0;

				// func txAdded(_ tx: BRTxRef)
				virtual void onTxAdded(const TransactionPtr &transaction) = 0;

				// func txUpdated(_ txHashes: [UInt256], blockHeight: UInt32, timestamp: UInt32)
				virtual void onTxUpdated(const std::string &hash, uint32_t blockHeight, uint32_t timeStamp) = 0;

				// func txDeleted(_ txHash: UInt256, notifyUser: Bool, recommendRescan: Bool)
				virtual void onTxDeleted(const std::string &hash, bool notifyUser, bool recommendRescan) = 0;
			};

		public:

			Wallet(const std::vector<TransactionPtr> &transactions,
				   const SubAccountPtr &subAccount,
				   const boost::shared_ptr<Listener> &listener);

			virtual ~Wallet();

			void initListeningAddresses(const std::vector<std::string> &addrs);

			uint32_t getBlockHeight() const;

			nlohmann::json GetBalanceInfo();

			void RegisterRemark(const TransactionPtr &transaction);

			std::string GetRemark(const std::string &txHash);

			uint64_t GetBalanceWithAddress(const std::string &address);

			// returns the first unused external address
			std::string getReceiveAddress() const;

			// writes all addresses previously generated with BRWalletUnusedAddrs() to addrs
			// returns the number addresses written, or total number available if addrs is NULL
			std::vector<std::string> getAllAddresses();

			// true if the address was previously generated by BRWalletUnusedAddrs() (even if it's now used)
			// int BRWalletContainsAddress(BRWallet *wallet, const char *addr);
			bool containsAddress(const std::string &address);

			// true if the address was previously used as an input or output in any wallet transaction
			// int BRWalletAddressIsUsed(BRWallet *wallet, const char *addr);
			bool addressIsUsed(const std::string &address);

			std::vector<TransactionPtr> getTransactions() const;

			std::vector<TransactionPtr> getTransactionsConfirmedBefore(uint32_t blockHeight) const;

			uint64_t getBalance() const;

			uint64_t getTotalSent();

			uint64_t getTotalReceived();

			uint64_t getFeePerKb();

			void setFeePerKb(uint64_t fee);

			uint64_t getMaxFeePerKb();

			uint64_t getDefaultFeePerKb();

			TransactionPtr
			createTransaction(const std::string &fromAddress, uint64_t fee, uint64_t amount,
							  const std::string &toAddress, const std::string &remark,
							  const std::string &memo);

			bool containsTransaction(const TransactionPtr &transaction);

//			bool inputFromWallet(const BRTxInput *in);

			bool registerTransaction(const TransactionPtr &transaction);

			void removeTransaction(const UInt256 &transactionHash);
				//fixme [refactor]

			void updateTransactions(const std::vector<UInt256> &transactionsHashes, uint32_t blockHeight,
									uint32_t timestamp);

			/**
			 * Returns the BRCoreTransaction with the provided `transactionHash` if it exists; otherwise
			 * NULL is returned.
			 *
			 * If BRCoreTransaction.JNI_COPIES_TRANSACTIONS is true, then the returned transaction is
			 * a copy of the Core BRTransaction - TBD caution when passed back into Core
			 *
			 * @param transactionHash
			 * @return
			 */
			const TransactionPtr &transactionForHash(const UInt256 &transactionHash);

			/**
			 * Check if a transaction is valid - THIS METHOD WILL FATAL if the transaction is not signed.
			 * You must call transaction.isSigned to avoid the FATAL.
		 	 *
			 * @param transaction
			 * @return
			 */
			bool transactionIsValid(const TransactionPtr &transaction);

			bool transactionIsPending(const TransactionPtr &transaction);

			bool transactionIsVerified(const TransactionPtr &transaction);

			/**
			 * Return the net amount received by this wallet.  If the amount is positive, then the balance
			 * of this wallet increased; if the amount is negative, then the balance decreased.
			 *
			 * @param tx
			 * @return
			 */
			uint64_t getTransactionAmount(const TransactionPtr &tx);

			uint64_t getTransactionFee(const TransactionPtr &tx);

			uint64_t getTransactionAmountSent(const TransactionPtr &tx);

			uint64_t getTransactionAmountReceived(const TransactionPtr &tx);

			uint64_t getBalanceAfterTransaction(const TransactionPtr &transaction);

			/**
			 * Return a BRCoreAddress for a) the receiver (if we sent an amount) or b) the sender (if
			 * we received an amount).  The returned address will be the first address that is not in
			 * this wallet from the outputs or the inputs, respectively.
			 *
			 * @param transaction
			 * @return
			 */
			std::string getTransactionAddress(const TransactionPtr &transaction);

			/**
			 * Return the first BRCoreAddress from the `transaction` inputs that is not an address
			 * in this wallet.
			 *
			 * @param transaction
			 * @return The/A BRCoreAddress that received an amount from us (that we sent to)
			 */
			std::string getTransactionAddressInputs(const TransactionPtr &transaction);

			/**
			 * Return the first BRCoreAddress from the `transaction` outputs this is not an address
			 * in this wallet.
			 *
			 * @param transaction
			 * @return The/A BRCoreAddress that sent to us.
			 */
			std::string getTransactionAddressOutputs(const TransactionPtr &transaction);

			uint64_t getFeeForTransactionSize(size_t size);

			uint64_t getMinOutputAmount();

			uint64_t getMaxOutputAmount();

			void signTransaction(const TransactionPtr &transaction, int forkId, const std::string &payPassword);

		protected:

		protected:
			Wallet();

			bool AddressFilter(const std::string &fromAddress, const std::string &filterAddress);

			TransactionPtr CreateTxForOutputs(const std::vector<TransactionOutput> &outputs, size_t outCount,
											  uint64_t fee, const std::string &fromAddress,
											  bool(*filter)(const std::string &fromAddress,
															const std::string &addr));

			TransactionPtr WalletCreateTxForOutputs(const std::vector<TransactionOutput> &outputs, size_t outCount);

			uint64_t WalletMaxOutputAmount();

			uint64_t WalletFeeForTx(const TransactionPtr &tx);

			void WalletUpdateBalance();

			bool WalletContainsTx(const TransactionPtr &tx);

			void WalletAddUsedAddrs(const TransactionPtr &tx);

			void setApplyFreeTx(void *info, void *tx);

			void balanceChanged(uint64_t balance);

			void txAdded(const TransactionPtr &tx);

			void txUpdated(const std::vector<UInt256> &txHashes, uint32_t blockHeight, uint32_t timestamp);

			void txDeleted(const UInt256 &txHash, int notifyUser, int recommendRescan);

			size_t KeyToAddress(const BRKey *key, char *addr, size_t addrLen);

			size_t WalletUnusedAddrs(std::vector<Address> &addrs, uint32_t gapLimit, int internal) const;

			uint64_t BalanceAfterTx(const TransactionPtr &tx);

			size_t WalletAllAddrs(std::vector<Address> &addrs, size_t addrsCount);

			void sortTransations();

			std::vector<UTXO> getUTXOSafe();

			uint64_t AmountSentByTx(const TransactionPtr &tx);

		protected:
			uint64_t balance, totalSent, totalReceived, feePerKb;
			uint32_t blockHeight;
			UTXOList utxos;
			std::vector<TransactionPtr> transactions;
			std::vector<uint64_t> balanceHist;
			std::vector<Address> internalChain, externalChain;
			//fixme [refator] set less than compare functor for allTx, invalidTx, pendingTx
			TransactionSet allTx, invalidTx, pendingTx;
			UTXOList spentOutputs;
			std::set<Address> usedAddrs, allAddrs;

			typedef std::map<std::string, std::string> TransactionRemarkMap;
			TransactionRemarkMap TxRemarkMap;
			std::vector<std::string> ListeningAddrs;

			pthread_mutex_t lock;

			SubAccountPtr _subAccount;
			boost::weak_ptr<Listener> _listener;
		};

		typedef boost::shared_ptr<Wallet> WalletPtr;

	}
}

#endif //__ELASTOS_SDK_SPVCLIENT_WALLET_H__
